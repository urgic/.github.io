
window.addEventListener("DOMContentLoaded", () => {
const canvas = document.getElementById("canvas");
const wordsContainer = document.getElementById("words");
const wordInput = document.getElementById("wordInput");
const buildBtn = document.getElementById("buildBtn");
const letterInput = document.getElementById("letterInput");
const addLetterBtn = document.getElementById("addLetterBtn");

let letters = {};
let squares = {};
let letterId = 0;
let squareId = 0;

/* ---------- BUILD BOXES ---------- */
function buildWords(lengths) {
// Clear previous squares
wordsContainer.innerHTML = "";
squares = {};
squareId = 0;

// Clear previous letters
for (const id in letters) {
const l = letters[id];
if (l.el.parentElement) canvas.removeChild(l.el);
}
letters = {};
letterId = 0;

lengths.forEach(len => {
const word = document.createElement("div");
word.className = "word";

for (let i = 0; i < len; i++) {
const sq = document.createElement("div");
sq.className = "square";
sq.dataset.id = squareId;

squares[squareId] = {
el: sq,
rect: null,
letterId: null
};

word.appendChild(sq);
squareId++;
}

wordsContainer.appendChild(word);
});

cacheSquareRects();
letterInput.focus();
}

/* ---------- ADD LETTER ---------- */
function addLetter(char) {
const id = letterId++;
const div = document.createElement("div");
div.className = "letter";
div.textContent = char;
div.dataset.id = id;

// Offset letters so they don't stack
const offset = (id % 10) * 20;
const baseX = 20 + offset;
const baseY = 150 + offset;

letters[id] = {
id,
el: div,
left: baseX,
top: baseY,
squareId: null,
locked: false
};

// Position letters using left/top
div.style.left = letters[id].left + "px";
div.style.top = letters[id].top + "px";

canvas.appendChild(div);
enableDrag(id);
}

/* ---------- CACHE SQUARE POSITIONS ---------- */
function cacheSquareRects() {
const canvasRect = canvas.getBoundingClientRect();
for (const id in squares) {
const r = squares[id].el.getBoundingClientRect();
squares[id].rect = {
left: r.left - canvasRect.left,
top: r.top - canvasRect.top,
width: r.width,
height: r.height
};
}
}

/* ---------- DRAG, TAP, DOUBLE-TAP ---------- */
function enableDrag(id) {
const l = letters[id];
const el = l.el;
let startX, startY, origX, origY;

el.addEventListener("pointerdown", e => {
if (l.locked) return;
el.setPointerCapture(e.pointerId);
startX = e.clientX;
startY = e.clientY;
origX = l.left;
origY = l.top;
if (l.squareId !== null) {
squares[l.squareId].letterId = null;
l.squareId = null;
}
});

el.addEventListener("pointermove", e => {
if (!el.hasPointerCapture(e.pointerId)) return;
l.left = origX + (e.clientX - startX);
l.top = origY + (e.clientY - startY);
el.style.left = l.left + "px";
el.style.top = l.top + "px";
});

el.addEventListener("pointerup", () => {
cacheSquareRects();
const snap = findSnapSquare(l);
if (snap !== null) placeInSquare(l, snap);
el.style.left = l.left + "px";
el.style.top = l.top + "px";
});

// Tap to lock/unlock
el.addEventListener("click", e => {
e.stopPropagation();
if (l.squareId !== null) {
l.locked = !l.locked;
el.classList.toggle("locked", l.locked);
}
});

// Double-tap delete
el.addEventListener("dblclick", () => {
el.style.transition = "opacity 0.2s";
el.style.opacity = "0";
setTimeout(() => {
if (el.parentElement) canvas.removeChild(el);
if (l.squareId !== null) squares[l.squareId].letterId = null;
delete letters[id];
}, 200);
});
}

/* ---------- SNAP LOGIC ---------- */
function findSnapSquare(letter) {
const cx = letter.left + 22;
const cy = letter.top + 22;
for (const id in squares) {
const sq = squares[id];
if (sq.letterId !== null) continue;
const r = sq.rect;
if (cx > r.left && cx < r.left + r.width && cy > r.top && cy < r.top + r.height)
return id;
}
return null;
}

function placeInSquare(letter, squareId) {
const r = squares[squareId].rect;
letter.left = r.left + r.width / 2 - 22;
letter.top = r.top + r.height / 2 - 22;
letter.squareId = squareId;
squares[squareId].letterId = letter.id;
}

/* ---------- USER INPUT ---------- */
buildBtn.addEventListener("click", () => {
const input = wordInput.value.trim();
if (!input) return;
const lengths = input.split(/\s+/).map(n => parseInt(n, 10)).filter(n => n > 0 && n < 20);
if (lengths.length) buildWords(lengths);
});

addLetterBtn.addEventListener("click", () => {
const char = letterInput.value.trim().toUpperCase();
if (!char.match(/^[A-Z]$/)) return;
addLetter(char);
letterInput.value = "";
letterInput.focus();
});

letterInput.addEventListener("keydown", e => {
if (e.key === "Enter") {
const char = letterInput.value.trim().toUpperCase();
if (!char.match(/^[A-Z]$/)) return;
addLetter(char);
letterInput.value = "";
letterInput.focus();
e.preventDefault();
}
});
});

